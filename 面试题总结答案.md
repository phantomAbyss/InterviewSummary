## 计算机网络

## 操作系统

## Java基础

## 并发

## JVM

### 美团

* 1、谈谈对Java内存模型的了解

  **预备知识：**

  * 1、通信机制：
    * 1、在命令式编程中，线程通信的方式有两种：共享内存和消息传递
       * 2、在共享内存的并发模型中，线程之间共享程序的公共状态，通过写读内存中的公共状态来隐式通信。但是同步是显示进行的，程序员必须指定某个方法或者代码块在线程之间互斥执行。
       * 3、在消息传递的并发模型中，线程之间没有公共状态，线程之间必须通过消息传递来显式通信。但是同步是隐式进行的，因为消息发送必须在消息接收之前。
       * 4、Java的并发是采用共享内存模型，整个通信过程都是隐式进行的，对程序员来说是完全透明的。
       * 5、同步是指程序中用于控制不同线程间操作发生相对顺序的机制。

  **Java内存模型(JMM)：**

     * 1、堆内存(存储所有的实例域、静态域、数组元素)在线程之间共享，但是局部变量、方法定义参数、异常处理器参数不会在线程之间共享。
     * 2、Java的线程通信由JMM控制，它定义了线程和主内存之间的抽象关系：线程之间的共享变量都存储在主内存中，每一个线程都会有一个私有的本地内存(用于存储该线程中已读/写共享变量的副本，但不是真实存在的)，
       <img src="F:\面试\面试\面试总结\面试题\img\Java内存模型抽象图解.jpg" alt="Java内存模型抽象图解" style="height:400px; width: 600px" />
     * 3、JMM通过控制主内存和每个线程的本地内存之间的交互，来为Java程序提供内存可见性保证。

  **重排序**

  * 1、类别：以下的重排序可能会导致出现内存可见性问题。
    * 编译器级别的重排序：不改变单线程的语义的前提下，重新安排语句的执行顺序。
    * 指令级并行的重排序：现代处理器采用了指令并行技术，如果不存数据依赖性，处理器可以改变指令的执行顺序。
    * 内存系统的重排序：由于缓存和读写缓冲区可能会导致数据读取的速度不一致，使得加载和存储操作可能会存在乱序操作，
  * 2、JMM对于重排序的处理
    * 1、对于编译器级别的重排序，JMM的编译器重排序规则会禁止特定类型的编译器重排序。
    * 2、对于处理器级别的重排序，JMM的处理器重排序规则会要求Java编译器在生成指令序列时插入特定类型的内存屏障，通过内存屏障指令来禁止特定类型的处理器重排序。

  **hapens-before**

  > * 1、从JDK5之后，Java使用新的JSR-133内存模型， 仅仅只允许把一个64位long/double型变量的写操作拆分为两个32位的写操作来执行，任意读操作在JSR-133中都必须具有原子性。
  > * 2、JSR-133模型使用happens-before来描述操作之间的内存可见性。
  > * 3、在JMM之中，如果一个操作的执行结果要对另一个操作可见，那么两个操作之间必须存在happens-before关系，没有对两个操作的执行顺序做要求。两个操作既可以是在一个线程内，也可以在不同的线程之间。
  > * 4、常见的happens-before规则：
  >   * 1、程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。
  >   * 2、监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。
  >   * 3、volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。
  >   * 4、传递性：如果A happens-before B, 且B happens-before C，那么A happens-before C。
  > * 5、一个happens-before规则对应于一个或多个编译器和处理器重排序规则。

  **数据依赖性**

  > * 1、数据依赖性包含3种类型：写后读、写后写、读后写
  > * 2、编译器和处理器在重排序时会遵守数据依赖性，不会改变存在数据依赖关系的两个操作的执行顺序，但是只针对于单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器和不同线程之间的数据依赖不会被编译器和处理器考虑。
  > * 3、当代码中存在控制依赖性时，会印象指令序列执行的并行度，因此编译器和处理器会采用猜测执行来克服控制相关性对并行度的影响。
  >
  > **as-if-serial语义**
  >
  > > * 1、不管怎么重排序，单线程程序的执行顺序不会被改变，编译器、runtime和处理器都必须要遵守as-if-serial语义。
  > > * 2、单线程程序按照顺序执行是依赖于as-if-serial语义保证的。

  **数据竞争和顺序一致性**

  > **数据竞争**
  >
  > * 1、在一个线程中写一个变量
  > * 2、在另一个线程中读同一个变量
  > * 3、写和读没有通过同步来排序
  > * 4、如果程序是正确同步的，程序的执行将具有顺序一致性——即程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同。
  >
  > **顺序一致性内存模型**
  >
  > > 这是一个理想化的参考模型，它提供了极强的内存可见性保证。
  > >
  > > 特性：
  > >
  > > * 1、一个线程中的所有操作必须按照程序的来执行
  > > * 2、不管程序是否同步，所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见。
  >
  > * 1、JMM在具体实现的基本方针为：在不改变程序执行结果的前提下，尽可能的进行编译器和处理器的优化
  > * 2、JMM不保证未同步程序的执行结果与该程序在顺序一致模型中的执行结果一致。
  > * 3、JMM不保证对64位的long型和double型变量的写操作具有原子性，而顺序一致性模型保证对所有的内存读写操作都具有原子性。

  **volatile**

  > * 1、对一个volatile变量的读，总是能看到(任意线程)对这个volatile变量最后的写入。
  > * 2、对任意单个volatile变量的读/写具有原子性，但类似于v++这种复合操作不具有原子性。
  > * 3、从JSR-133开始，volatile变量的写-读可以实现线程之间的通信(一个线程向主内存中写一个volatile变量，另一个线程从主内存中读取之前某个线程写入的volatile变量，实质是一个线程通过主内存向另一个线程发送消息)。
  > * 4、volatile写的内存语义：当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存中。
  > * 5、volatile读的内存语义：当写一个volatile变量时，JMM会把该线程对应的本地内存置为无效，然后从主内存中读取共享变量。
  >
  > **volatile语义的实现**
  >
  > > * 1、为了实现volatile的内存语义，编译器生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。
  > > * 2、volatile的读-写具有锁的释放-获取相同的内存语义。
  > > * 3、JMM采取保守的内存屏障插入策略：==》可以保证在任意处理器平台上，任意的程序中都能得到正确的volatile内存语义。
  > >   * 1、在每个volatile写操作的前面插入一个StoreStore屏障(保证上面的所有的普通写都在volatile写之前刷新到主内存中)。
  > >   * 2、在每个volatile写操作的后面插入一个StoreLoad屏障(避免volatile写与后面可能有的volatile读/写操作重排序)。
  > >   * 3、在每个volatile读操作的后面插入一个LoadLoad屏障(禁止处理器把上面的volatile读与下面的普通读重排序)。
  > >   * 4、在每个volatile读操作的后面插入一个LoadStore屏障(禁止处理器把上面的volatile读与下面的普通写重排序)。

  **锁**

  > * 1、锁不仅可以让临界区互斥执行，还可以让释放锁的线程向获取锁的另一个线程发送消息。
  > * 2、当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。
  > * 3、当线程获取锁时，JMM会把该线程对应的本地内幕才能置为无效，从而使得被监视器保护的临界区代码必须从主内存中读取共享变量。

* 2、对G1垃圾收集器的算法细节的了解
* 3、对是红黑树的了解？有什么特点
* 4、HashMap的底层原理
* 5、类加载过程
* 6、说说MySQL的索引结构？为什么用B+树而不用哈希和B树？
* 7、InnoDB和MyISAM的索引结构的区别？InnoDB主键索引和联合索引结构上的区别？InnoDB和MyISAM还有哪些区别？
* 8、分库分表
* 9、redis用过吗？一般怎么使用redis？redis的底层结构？为什么要使用Redis？了解Redis持久化吗

## MySQL

## Redis

## Spring

## Mybatis

## SpringBoot

## 微服务

## 算法题

### 美团

* 1、合并有序数组
* 2、删除链表的倒数第n个节点